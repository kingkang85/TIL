# 24.07.30.
## 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- **정수나 정수로 표현할 수 있는 자료**에 대해서만 적용 가능
- 카운트를 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- **시간 복잡도** : `O(n+k)`
  - n은 리스트 길이
  - k는 정수의 최댓값

### 정렬 과정
1. Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 누적합을 counts에 재할당
3. Data의 마지막 원소부터 시작<br>
→ 인덱스 번호에 맞는 counts에 -1<br>
→ 정렬된 집합 Temp의 인덱스 번호에 Data의 해당 원소 삽입<br>
4. Temp 업데이트 완료 후 정렬 작업 종료

#### 데이터의 마지막 원소부터 시작하는 이유는?
  - Data = [0, 4, 1, 3, 1, 2, 4, 1]이라고 하자
  - 원래 1의 인덱스 번호는 2, 4, 7
  - 첫 번째 원소부터 시작하면, Temp에 7, 4, 2 순으로 삽입
  - 1만 있을 때는 문제 없어 보이지만, 좌표라고 생각해보자
  - (2, 1), (3, 1), (4, 1)처럼 정해진 순서가 있고 x 순서를 유지한채로 정렬하고 싶다면, 마지막 원소부터 시작하는 것이 옳은 방법
  
### 파이썬 코드
```py
def CountingSort(data, temp, K):
    counts = [0] * (K+1)  # 카운트 배열
    
    # data의 각 요소의 개수 세기
    for i in range(len(data)):
        counts[data[i]] += 1
    
    # counts의 누적합 구하기
    for i in range(1, K+1):
        counts[i] += counts[i-1]
    
    # data의 마지막 원소부터 temp에 자리 잡기
    for i in range(len(temp)-1, -1, -1):
        counts[data[i]] -= 1  # 인덱스로 사용하므로 누적 개수 1 감소
        temp[counts[data[i]]] = data[i]
        
    return temp
        
arr = [0, 4, 1, 3, 1, 2, 4, 1]
sorted_arr = [0] * len(arr)  # 정렬된 배열
k = max(arr)
print(CountingSort(arr, sorted_arr, k))  # [0, 1, 1, 1, 2, 3, 4, 4]
```

## 참고
### 완전 검색 (Exaustive Search)
- 모든 경우의 수를 나열하여 확인하는 기법
- Brute-force 혹은 generate-and-test 기법이라고도 함
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 수행 속도는 느리지만, 해답을 찾을 확률이 높음

### 모든 경우의 수를 어떻게 나열할 것인가 ⇒ `순열`
#### 예) {1, 2, 3}을 포함하는 모든 순열
```py
for i1 in range(1, 4):
  for i2 in range(1, 4):
    if i2 != i1:
      for i3 in range(1, 4):
        if i3 != i1 and i3 != i2:
          print(i1, i2, i3)
```

--- 
### 탐욕(Greedy) 알고리즘
- 그 순간 최적이라고 생각되는 것을 선택해 나가며 최종적인 해답에 도달
- 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 됨

#### 동작 과정
1. **해 선택** : 부분 문제의 최적 해를 구한 후, 이를 **부분해 집합**에 추가
2. **실행 가능성 검사** : 부분해 집합이 실행 가능한지 확인
3. **해 검사** : 부분해 집합이 **문제의 해**가 되는지 확인<br>
⇒ 아직 전체 문제의 해가 완성되지 않았다면, 1부터 다시 시작
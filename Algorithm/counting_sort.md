# 24.07.30.
# 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- **시간 복잡도** : `O(n+k)`

## 정렬 과정
1. Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소 조정
3. counts[1]을 감소시키고 Temp에 1 삽입
  - 데이터의 마지막 원소부터 시작
  - 왜 마지막부터?? 1을 생각해봐 원래 1의 인덱스는 2, 4, 7이지??
  - 앞에서부터 시작하면 temp에 7, 4, 2로 들어가지
  - 1만 있을 때는 문제 없어 보이지만, 좌표라고 생각해봐
  - (2, 1), (3, 1), (4, 1)처럼 정해진 순서가 있고, x 순서를 유지한채로 정렬하고 싶다면, 앞에서부터는 안 되겟지 ~! 그래서 뒤에서부터 해라
  

  다시 정리해라ㅇ

# 완전 검색 (Exaustive Search)
- 모든 경우의 수를 나열하여 확인하는 기법
- Brute-force 혹은 generate-and-test 기법이라고도 함
- 일반적으로 경우의 수가 상대적으로 작을 때 유용

## 모든 경우의 수를 어떻게 나열?? 순열
```py
for i1 in range(1, 4):
  for i2 in range(1, 4):
    if i2 != i1:
      for i3 in range(1, 4):
        if i3 != i1 and i3 != i2:
          print(i1, i2, i3)
```

# 탐욕(Greedy) 알고리즘
- 그 순간 최적이라고 생각되는 것을 선택해 나가며 최종적인 해답에 도달

# 24.08.06.
# 스택 (Stack)
- 자료를 쌓아 올린 형태의 자료구조
- 선형 구조
- ${\textsf{\color{red}LIFO (후입선출)}}$ : 마지막에 삽입한 자료를 가장 먼저 꺼냄

## 스택의 연산
- **삽입 (push)** : 자료 저장
- **삭제 (pop)** : 자료 꺼냄
- isEmpty : 스택이 공백인지 아닌지 확인
- peek : 스택의 top에 있는 item 반환 (개수가 줄지 않으므로 pop과는 다름)

## 스택의 구현
- push 알고리즘
```py
def push(item):
  s.append(item)
```

- pop 알고리즘
```py
def pop():
  if len(s) == 0:  # underflow
    return
  else:
    return s.pop()
```

underflow, overflow 항상 잘 고려하자 ~!!

### 스택의 응용 : Fuction call
- 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 LIFO 구조이므로, **스택을 이용하여 수행 순서 관리**
- `함수 호출이 발생하면` 지역변수, 매개변수 및 수행 후 복귀할 주소 등을 스택 프레임에 저장하여 시스템 스택에 삽입
- `함수의 실행이 끝나면` 시스템 스택의 top 원소를 삭제(pop)하면서 프레임에 저장된 복귀 주소를 확인하고 복귀

## 재귀호출
- 자신을 다시 호출하는 구조
```py
def fibo(n):
  if n < 2:
    return n
  return fibo(n-1) + fibo(n-2)
```
⇒ 엄청난 중복 호출이 존재한다는 단점

## 메모이제이션
- 이전에 계산한 값을 메모리에 저장해서 전체적인 실행 속도를 빠르게 하는 기술

```py
def fibo1(n):
  global memo
  if n >= 2 and memo[n] == 0:
    memo[n] = fibo1(n-1) + fibo(n-2)
  return memo[n]

memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
```

## DP (동적 계획)
- 그리디 알고리즘과 같이 ${\textsf{\color{red}최적화 문제}}$를 해결하는 알고리즘

```py
def fibo2(n):
  f = [0] * (n+1)
  f[0] = 0
  f[1] = 1
  for i in range(2, n+1):
    f[i] = f[i-1] + f[i-2]

  return f[n]
```

# DFS (깊이 우선 탐색)
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회 방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 DFS를 반복해야 하므로 **후입선출 구조의 스택** 사용
- 재귀 구조로도 구현 가능 !!

정리 좀 해라잉
나만의 dfs 알고리즘을 만들자.

# BFS (너비 우선 탐색)
